1
00:00:00,140 --> 00:00:16,716
Speaker 0: Welcome, everybody, to Bitcoin OpTech Newsletter number 243 recap on Twitter Spaces. We have a special guest who will introduce himself shortly. I'm Mike Schmidt, contributor at OpTech and also executive director at Brink, funding open source Bitcoin developers. Murch?

2
00:00:17,602 --> 00:00:25,079
Speaker 2: Hi, I'm Murch. I do Bitcoin stuff at Chaincode Labs. I've been working on reviewing a bit and writing a bit this week.

3
00:00:25,724 --> 00:00:26,275
Speaker 0: And Alikos?

4
00:00:27,405 --> 00:00:46,099
Speaker 1: Hi, everyone. I'm Alikos. Until recently, I was the lead maintainer of BDK with the BDK library. Now it's kind of in between, not really in between jobs, but yeah, I'm kind of stepping down from BDK a little bit. So it's kind of unclear what I'm doing right now. But yeah, I'm here representing BDK, even though I'm not anymore lead maintainer of the project.

5
00:00:46,740 --> 00:01:38,139
Speaker 0: And we don't have a BDK related news item this week, but there is a major restructuring that we covered in the PR section. And I think it would be interesting to have some thoughts on that. So I thought it would be great to have a look about BDK 793 later in our discussion. So thank you for joining us. Like I said, there's no news items this week that we noted in 243. But we do have a monthly segment in which we highlight interesting updates to Bitcoin wallet services and other client software that use Bitcoin or Lightning. And there was quite a few updates that I found in trolling through my notes and some of the repositories that I take a look at. So we can kind of jump in and go through that first. Murch, any announcements before we jump into that?

6
00:01:38,683 --> 00:01:39,298
Speaker 2: I don't have any.

7
00:01:40,104 --> 00:02:16,559
Speaker 0: All right. Well, the first interesting client software update that we noted this week is Zappo Bank supporting Lightning. And so I think folks maybe have heard of Zappo before. I think that they're now called Zappo Bank because I think they spun off the custodian portion to Coinbase and are left with this Zappo Bank. And they have a series of mobile apps and they have announced support for those mobile apps to be able to send Lightning payments using those Lightning mobile apps. And they've mentioned the underlying infrastructure provider as LightSpark. Murch, any thoughts on that integration?

8
00:02:18,042 --> 00:02:27,679
Speaker 2: I have not tried it out myself yet. I think it's pretty cool that a bonafide bank is getting on the payment rails of Bitcoin, even if it was a Bitcoin company first.

9
00:02:30,181 --> 00:02:46,939
Speaker 0: Yeah, and it's also interesting. I think LightSpark, there's some mystique and mystery about what they're working on. So it's nice to see that some of that behind the scenes work that they're doing is coming to fruition and with a fairly large player in a bank. So it's interesting to see, hopefully see more from LightSpark.

10
00:02:47,860 --> 00:03:00,999
Speaker 2: I don't have a lot of insight and knowledge there, but it sounded to me like they first decided that they were going to do something with Lightning and then they tried to figure out what their product's going to be. So I think that might have added to the mystique.

11
00:03:01,785 --> 00:03:36,539
Speaker 0: Perhaps. The second thing that we noted in the newsletter was a TypeScript library for mini script descriptors. So TypeScript is a JavaScript based language and there is now a descriptor library with the fairly uncreative name of Bitcoin descriptors library, which has support for PSBT descriptors and mini script. And then there's also as part of the PSBT process, the signing or the finalizing, there's a support for single signing as well as hardware signing. Murch, did you get a chance to look at this library at all?

12
00:03:37,321 --> 00:04:09,379
Speaker 2: I did look at it a little bit. So I didn't look at the code too much, but I was very impressed by the readme. The readme looks very elaborate and well readable. And the other thing that really impressed me is that the whole project appears to have started only in January. So they're only two months in and they seem to have broad support for a bunch of things already. So whoever is going to use that, I think you'll enjoy the documentation they're writing. Yeah. Let me know what the code's like. when you look at that more.

13
00:04:10,440 --> 00:04:58,319
Speaker 0: I found after the fact that there's actually a web site, we linked to the GitHub for the project, which is what we usually do. And sometimes we actually listening to the project's website if there is one. And I wasn't aware of that there was one, but in preparing for the spaces, I did stumble across the vicoinerlab.com website, which has even more documentation and discussion about what this library does. So in addition to the readme that Murch was impressed with, there's even more documentation on their website. So check that out. I noticed there's talk of mini script. There's talk of descriptors. I don't see anything policy related and maybe Murch. It's a good opportunity, although I think we've done it a few months ago to maybe just quickly outline, like what's the difference between mini script descriptors and policy?

14
00:04:58,900 --> 00:05:44,979
Speaker 2: I think that, yeah, so there's multiple levels of mini script. Mini script by itself is a subset of the script language that is, well, that is not ambiguous, I guess. So you can with mini script policy describe a somewhat human readable policy of what you want the wallet to behave like. And then the mini script compiler will compile that to mini script, which in turn is a more readable representation of an underlying script, as in the Bitcoin transaction language. So I assume that they just cover all of that and don't the reader with the distinctions there immediately, but I have not looked to that level to confirm that.

15
00:05:45,900 --> 00:06:41,003
Speaker 1: I don't have any experience with this library specifically. I think maybe they only do like the second step where you have a descriptor and you want to create a script row between scripts, given the descriptor so that you can use it for generating addresses or monitoring funds if you've received some funds or something like that. So maybe that's probably a bit easier just implementing this descriptor to script compared to the full mini script libraries like the rust mini script and the C++ library. Then they also have the compiler. So those libraries, they take the very high level description and they compile it down. Maybe that's a lot of complexity that they maybe don't really care about initially. So they just want to start with, you give me the script or I can give you a script so you can monitor all this and et cetera. That's already like a big chunk of what most users need, actually. Most of the time you just need that. if you have a JavaScript wallet, you are fine with just that. You don't need the compiler in your project. So.

16
00:06:42,222 --> 00:07:59,799
Speaker 0: Yeah, that's good insight. And to Murch's point, this seems like a fairly young project. So potentially some of that stuff could be added in the future. The next item that we noted was Breeze Lightning SDK being announced. And we linked to a blog post from Breeze announcing this open source SDK. It seems like they're targeting mobile developers and specifically mobile developers that are building apps that aren't necessarily Bitcoin focused or wallet focused. So it's a way to add in and lightning features to an existing app. So it would be nice to see some adoption of this SDK because it would mean broader adoption of lightning and Bitcoin in the mobile app realm, which is interesting. And the SDK behind the scenes in order to fulfill on that lightning integration and some of the Bitcoin features actually uses Greenlight. Which is a Blockstream product, and then they also provide some of their own Breeze LSP features. And I think there's some Fiat on and off ramps that they're planning to work on using Moonpay behind the scenes. And so it's pretty cool. It's nice to see Greenlight also getting some usage. Murch, did you get a chance to look at the SDK and some of the features?

17
00:08:00,760 --> 00:08:57,499
Speaker 2: I have not dived into deeply, but the idea that you can just provide a wrapper for all of the lightning interactions seems very sensible to me. Just like with a credit card, you don't really need to know how the credit card works under the hood to understand the concept that you can use it to perform a payment that somehow in the background is settled between your bank and the merchant. So if they actually manage to wrap up everything that needs to happen in the background and you essentially just come down to a, I need to pay this amount and it's maybe even presented in Fiat and they have wrapped all the around for the user. Well, presumably lightning payments, but yeah, that sounds pretty sweet. application of using Greenlight in the background and plugging it into a front end like Breeze.

18
00:08:58,681 --> 00:09:54,699
Speaker 0: Yeah, very cool. And for folks who aren't familiar with Greenlight and how that fits in here is that a node will actually be provisioned that is managed by the Greenlight Blockstream team, but they don't hold your keys. They never have any of the keys or the keys never touched their infrastructure. So they're merely the ones managing the node. So these users would have their own node and then their own keys as well. And my understanding from the announcement from Breeze is also that if there's multiple apps that integrate Breeze, that the quote unquote end user can actually see the same balance across their different apps. So there'd be like one balance shared between the apps if folks are using the Breeze SDK, which is pretty cool. I haven't tried it, didn't run the SDK, but just from their announcement and digging into some of the documentation, that's what I gleaned.

19
00:09:55,620 --> 00:10:47,719
Speaker 2: I think it's also interesting to see that now that Lightning infrastructure is maturing and more services are offering packaged products, the possibility to take multiple of them and plug them together to offer yet another composed product is growing. And yeah, so Greenlight on the one hand here doing the heavy lifting on the Lightning Network side, Breeze offering basically the repackaging, the wrapper, the integration with other processes is pretty cool. Kind of reminds me how LDK plugs into Blue Wallet to do the heavy lifting on the Lightning side where Blue Wallet now can offer non-well self-custodial Lightning to its users. I think it's really nice to see how things are coming together slowly and products are getting more refined that way.

20
00:10:48,920 --> 00:11:46,279
Speaker 0: The next piece of software that we spoke about in the segment of the newsletter is PSBT based exchange. open-ordex launches. And this is an open source exchange essentially for trading ordinals using PSBTs. And since you're actually trading Bitcoin for Bitcoin, it can all be done in this pre-signed PSBT. or I guess the seller signs their portion of the PSBT. And that acts as part of an order book that somebody can then complete by signing and then broadcasting the rest of that PSBT to the network. Murch, any thoughts on this? I thought it was interesting that PSBT functioned as like an order in sort of like an order book. I think there's like Noster involved here as well for some of the order book stuff, but PSBT is like the format that this order book is being passed around in.

21
00:11:47,361 --> 00:13:49,639
Speaker 2: Yeah, I think that's a really nice way of... I mean, as I may have mentioned before, I'm not really that much following the whole ordinal inscription movement or hype, but it is a kind of nifty way of presenting and producing this marketplace. So when an inscription is written to the blockchain, the inscription is sort of attached to one specific Satoshi. And the ordinal scheme, of course, gives a framework with how they supposedly are tracked and they're uniquely identified. So you can sort of say, well, exactly this. Satoshi owns the inscription. And I saw another PSBT based ordinal marketplace being announced on Twitter the other day. And they basically use a transaction structure where the first input is just a dummy input. And then the second input basically provides the Satoshi that holds the inscription and also leaves a slot open for the buyer to put their own address. And since you can have SIGHASH flags where each signature in Bitcoin has a modifier that says what parts of the transaction it commits to. And if you use the SIGHASH single flag, you can set that you're just committing to certain inputs and outputs. So in this case, for example, you would build a transaction that has certain parts still open that the other side that wants to take the offer can plug into. But then you provide the input and thus determine what you're offering to sell. And you also provide an output which basically says how much money will appear in a specific address of yours. So, yeah, it's kind of nifty, even though I'm not really that excited about the whole thing. But yeah, kind of cool how they're doing that.

22
00:13:50,780 --> 00:15:09,779
Speaker 0: I see Rendell in the space is giving thumbs up. I think it was his tweet that I saw originally. that was that brought this project to my attention. So next item that we saw that was notable for the Bitcoin OpTech community was BTC pay server CoinJoin plugin being released. And I think the BTC pay folks had some announcements on Twitter, but I think the most comprehensive announcement was from the Wasabi wallet team. So we noted their blog post in the newsletter. And it's an opt in feature for BTC pay server merchants that can turn this on and the plugin supports the Wasabi protocol for Coin joins. And so I think there's if you dig into the post a bit, there's a few different ways in which you can be doing Coin joins. And one that we didn't explicitly outline was that merchants can actually when they when they do their scheduled payouts can actually use Coin joins to do those payouts as a secondary option within this plugin. So take a look at the write up from Wasabi. And if you're into Coin joins and you're into Wasabi and your BTC pay merchant, check it out. March, did you dig into this item at all?

23
00:15:10,380 --> 00:18:40,439
Speaker 2: Yeah, I did read the blog post. I wanted to point out maybe what sort of thread model people are thinking about when they are considering to use this plugin. So you may have seen, for example, when big exchanges do consolidations on the network, like Binance recently, that people immediately see, oh, this is Binance doing consolidations. And why is it so easy to tell? Well, in Binance's case, Binance actually heavily reuses singular addresses. And so they have like one address that's responsible for their hot wallet, one address that or maybe a few, but very few. So whenever somebody deposits into Binance, they'll see their funds flow to the hot or cold wallet of Binance afterwards. So it's extremely obvious to anybody watching, well, which funds go through Binance and end up there. The same can be mitigated a little more if you, instead of using the same address for your hot wallet over and over again, if you use new addresses as you should, and especially if you use a separate address for every single deposit of the same user. So even though you could have a single address for a depositor that they can always deposit into the same address and you know how to tie their deposit to their IOU or the list in the database. So, well, anyway, the problem with that is if you are a merchant and somebody comes and pays for a product in your store, they learn what you take. So or they know, of course, what you take. So they created in order to pay you. And if they keep track of that, they might be able to fingerprint your wallet. And if you spend that, you take so with a bunch of other coins, you they might learn about other addresses of your wallet. So inherently, if you have a large volume of payments, it might be difficult for you to to have financial privacy. And for example, you don't want to leak to competitors how much volume your shop is doing or whether you're cash strapped currently and your money is moving extremely quickly because you have to pay for deliveries with the money you just took in or other things that people might learn by using by watching your financials. So the idea here is instead of just directly scooping up all your funds and consolidating them into one address, you can move them through a coin join where it gets potentially mixed with a bunch of other merchants or other users that are participating in in Wasabi's coin join scheme. And that way you break the mystery shopper attack and you you also break the common input heuristic that says probably all inputs on that transaction belong to the same wallet. So, yeah, privacy is not a crime. Just in case that wasn't clear, it is. So the crime supposedly is money laundering, but just keeping your financials private is not a crime and actually a good business sense. So, well, that went on a little longer than I thought.

24
00:18:42,681 --> 00:20:57,630
Speaker 0: Yeah, that was great context. Thanks for for walking through that merch. The next item that we noted in the client services update section of the newsletter is mempool.space adding enhanced CPFP support. So mempool.space is a block explorer and they've had support for child pays for parent previously. And what child pays for parent is is a technique for fee bumping a transaction. So if I have a transaction at, say, paying one satoshi per V byte in the mempool and it's not getting confirmed at the speed that I had hoped, I can actually create a child transaction at a higher fee rate. Let's say 10 satoshis per V byte. And because that child transaction depends on the parent transaction, when a miner is looking at including that one satoshi per V byte in a block, it'll actually consider that, hey, I actually get this 10 satoshi per V byte transaction with it, which has the effect of raising the fee rate, the effective fee rate of the parent transaction. And so that's been represented in mempool.space as block explorer for transactions that are in the mempool. There was this additional field for effective fee rate. So instead of seeing the one satoshi per V byte fee, you'd actually see the effective fee rate, including that child transaction for transactions that were in the mempool. But this new change that they have has a similar user interface and similar data for transactions that are already confirmed. So if you look at an old block and you see that the average fee rate is 20 satoshis per V byte and you see this transaction in there that was paying one satoshi per V byte, now you get the context of that and it'll actually include ancestor and descendant information about transactions that are in a block. Which would maybe enlighten somebody as to why a low fee rate transaction got confirmed, because it had some descendants that paid for its fee rate, essentially. Murch, did you get a chance to look at this and maybe you want to augment or correct any of the CPFP information that I outlined about mempool.space? No, you did a marvelous job of explaining all that.

25
00:20:59,780 --> 00:21:40,590
Speaker 2: But yeah, I'm pretty excited that they're now surfacing that information because previously the minimum fee rate on blocks could really be confusing if really the effective fee rate of all transactions in a block was say 20 satz per V byte or more. Sometimes if a package of transactions came in with a low fee rate parent and a high fee rate child, it would look like that the minimum fee rate was lower in the block, but really it actually all fit because the child paid for it and it was sensible to include the transaction. Next item from the newsletter that we noted was SPARROW version 1.7.3 being released.

26
00:21:44,320 --> 00:22:32,625
Speaker 0: And this release includes BIP129 support for multisig wallet setups and custom block explorer support among other features. So Murch, I think we've talked about another wallet standardization, which is similar and I get confused by this sometimes, which is BIP329. is the labeling BIP. The ability to label transactions and inputs and outputs and addresses, I think is BIP1.329, which was assigned in the last few months. This is similar in that it's a multisig wallet setup BIP, but it's BIP129. We haven't talked about this much in the newsletter or in our spaces. Are you familiar enough with BIP129 to maybe give a quick overview Murch? Yeah.

27
00:22:36,783 --> 00:24:22,320
Speaker 2: So BIP129 is a informational BIP and it is basically a standard, or maybe not informational, but rather it's a procedure on how multiple different wallets could coordinate if they want to build a transaction together. So we've talked a bunch about PSBT and descriptors in the last months, but the part that was missing still is how do wallets even start talking to each other in order to exchange that information with each other? So BIP129 addresses the steps on, like, let me quote from the BIP. So whether the multisig configuration is correct and not tampered with, whether the keys are leaked during the setup, and whether the signer must persist information and in what format. So it basically gives a framework for wallet implementers on how to talk to other wallets to coordinate a multisig transaction. Then, of course, once you have coordinated and you're talking to each other, you can use the protocols that are specified, like music, on how to actually produce the signatures and securely coordinate that. But, like, how do you even coordinate that you want to make a transaction together? So I think this was written by a few wallet developers that basically were interested in having a standard on how to do this together. I see names of people that work on Nunchuck, CoinKite, Shift Crypto being a hybrid wallet producer. I don't know who Aaron Chen is, but Rodolfo Nova calls for CoinKite, right?

28
00:24:24,382 --> 00:25:01,079
Speaker 0: The next piece of software we noted this week was StackWallet adding CoinControl and BIP47 slash PayNIM features. Merch, I don't know if you want to scold me for linking to the coin selection entry on OpTek with CoinControl. I know I sort of use those a bit interchangeably and I know you have a preference for coin selection versus CoinControl, the meaning of each. But both of these are privacy-related features and potential privacy features added to the StackWallet, which is not a wallet we've covered previously.

29
00:25:02,125 --> 00:26:05,079
Speaker 2: Yeah, I hadn't seen StackWallet before either. It looks like it is a wallet for Monero, Bitcoin, Bitcoin Cash, and a few other things. The features that we described in our newsletter seem to include CoinControl, which yes, I distinguish from coin selection. In my opinion, coin selection is the term to use when you're talking about the automated process of how your wallet picks the coins it is using to fund a transaction, aka input selection. Whereas CoinControl usually refers to when the user has the ability to manually select which UTXOs they want to spend. And yeah, I've also seen people use CoinControl for coin selection and vice versa, so there seems to be some confusion here. Yeah, other than that, it seems to be GPL licensed and I don't know what Dart is as a programming language. I have no idea about this wallet beyond that.

30
00:26:05,440 --> 00:27:10,218
Speaker 0: Yeah, I think Dart is like a Google language and I think maybe does something with Java or JavaScript. Yeah, I guess we can make everybody angry because we covered PayNIMS, which is like a samurai thing. We've covered Wasabi and we've covered ordinals, so everybody can be angry about our coverage of software this week. The last one is Wasabi, so we noted Wasabi is kind of a WabiSabi plugin for BTC pay. And the last one here is Wasabi wallet version 2.0.3 being released and actually was released the day before the newsletter. So when the Wasabi developers actually appended commit, which did this write up. And this adds Taproot coin join signing and Taproot change outputs along with also coin selection, or sorry CoinControl, sorry, merch, for sending. And then some speed improvements and additional changes that were less relevant to the OpTech audience. Any thought on Wasabi and merch?

31
00:27:11,568 --> 00:28:34,320
Speaker 2: This time you did it on purpose, right? Yeah, so in this release they have opt-in manual CoinControl for payments. So I think on the one hand that is always cool for actual power users that want to keep track really for every single UTXO that they receive and spend. Where it's coming from, who knows about the ownership of that UTXO, what other context might be available, and they want to be extremely deliberate about what they mix and don't mix. But in the long term, I don't think that is a viable scalability strategy for privacy, right? If you expect everybody to jump through these sort of hoops, you just end up, most people, not doing any of it. So that's why I tend to think more about how coin selection should work so we can hopefully automate most of that and have good standards for how wallets pick transactions that have good privacy automatically. Maybe even recognize context or allow you to label addresses when you receive and then deduce context from that. But yeah, it's a long road. We'll get there eventually and meanwhile power users can do it manually.

32
00:28:35,202 --> 00:29:35,299
Speaker 0: We noted one release this week in the newsletter which is LND 0.16.0 Beta RC3. And I know last week we mentioned that we were going to pull in someone who could walk us through the features of this release similar to what we did with Core Lightning a few weeks back. And that is underway. The Lightning Labs folks preferred to jump on and talk with us about the features after this is actually released. So we'll get them either next week or the week after and I think they'll provide a better overview of this release than we could. So I'm okay punting it again, merch, if you are. All right, great. Speaking of LND, the first notable code change, LND 7448 adds a new rebroadcaster interface to resubmit unconfirmed transactions. Merch, why would LND need to be resubmitting unconfirmed transactions to be broadcast?

33
00:29:36,502 --> 00:32:49,299
Speaker 2: So in the past few months at this point, there's been a new sort of demand on block space. And we've actually had a growing subset of transactions that have not confirmed in a very long time. We are now at over 916 megabytes of memory usage for mempool.space's mempool monitor, which is clearly slightly more than the 300 megabyte that mempools by default hold. So everything below 4.99 sats per view byte is currently being purged from the mempool or from default mempools. So what LND is addressing here is when a transaction gets dropped from other mempools, there is no mechanism for someone with a big mempool, such as mempool.space, for example, that will get the transaction resubmitted to other people's mempools. So having a bigger mempool is actually not helpful unless you are a miner and are worried that eventually the mempool will be empty and you will want to include transactions that you had previously purged, or that default mempools had previously purged. So there has been work in the past on Bitcoin Core to make every node rebroadcast transactions when they had transactions that they would have included in the previous block, but didn't see in the block. That is still, I guess that's just starting up again. There was a break there and the author of those PRs not working on it for a while. But for LND concretely to solve their own problem where the wallet is responsible for keeping transactions in mempools and making sure that they get rebroadcast if they didn't confirm yet, they are now adding this rebroadcaster interface. What it does specifically is it offers the transaction to the connected full node. And of course, if the full node already has the transaction, it will not resubmit it to its peers. So there's no big privacy loss here. But if the attached full node has purged the transaction previously, but now the minimum fee rate of their mempool is low enough that it would fit again, the node will accept it again from the LND and will of course also then offer it to its peers again since it's new content of a new inventory. LND was doing this already when it was running in neutrino mode. because in the neutrino node, it doesn't have a dedicated full node that it's talking to, but can just communicate with any nodes. that offered BIP157158, which is the client-side compact block filters. And now also if you have a dedicated full node, it will every block try to resubmit unconfirmed transactions to that full node. And that full node, if it hadn't had that transaction but can accept it now, will relay it. So this is a mechanism on how to get transactions back in the mempool after they were dropped.

34
00:32:50,320 --> 00:33:00,199
Speaker 0: Burch, do you have a personal preference or opinion on whether this should be a wallet responsibility or a responsibility at the node level?

35
00:33:00,920 --> 00:35:56,320
Speaker 2: I think I can argue both sides. So if it's a wallet responsibility, you get the advantage that if you change your mind and the transaction was purged widely from mempools, you can just not rebroadcast it, but rebroadcast a different variant. That plays well even if you had signaled finality on your transaction originally and you're mostly connected to a network that respects the finality of transactions, aka doesn't do mempool full RBF yet. It doesn't matter nearly as much if the whole network moves to mempool full RBF because then every transaction that just pays more fees will propagate. So if you change your mind, you can just write a new variant that conflicts with the original and whether it's been dropped from mempools or not, it will propagate if it just pays more fees. So that's actually one reason why I think mempool full RBF would be more useful now than it had been when it was originally proposed because with the extremely full mempools lately, I would expect that more people have stuck transactions and need to rebroadcast them. So that's why it might have been better for wallets to have the ownership or the onus of making sure when a transaction gets rebroadcast. The receiver also has an interest of transactions going through because if they get paid, they want to, of course, make sure that the payment goes through. So a receiver might also want to rebroadcast transactions that pay them. Finally, I think it would be a huge boon for privacy because, of course, when a wallet continues to rebroadcast a transaction, the nodes that are connected to the node that serves the wallet will see that a transaction gets offered more often than it should be from specific nodes. And they can deduce that the node is connected to the original sender or maybe receiver of this payment transaction. So if we instead move to a paradigm where every node, when it sees that it has a transaction that should have been included in the previous block but didn't get included, when it says, hey, that should have been in the last block, let me rebroadcast that, that would lead to every single node doing these rebroadcasts and thus getting much better privacy for sender and receiver in that case. So in the long run, I would hope, A, that we just get away from opt-in RBF and move to full RBF where every transaction is just evaluated on the merit of the fees that it is paying currently. And then B, every node rebroadcasts every transaction whenever they see that it should have been included.

36
00:35:57,624 --> 00:36:02,119
Speaker 0: Thanks for elaborating on that, Murch. Anything else on this LND rebroadcast PR?

37
00:36:03,548 --> 00:36:04,877
Speaker 2: No, I think that is all.

38
00:36:06,002 --> 00:36:33,079
Speaker 0: Well, the last pull request that we highlighted in the newsletter this week is BDK 793. And our special guest has been waiting 45 minutes to walk us through this PR. So without further ado, Alcos, what is this major restructuring of BDK? What is the BDK core project? And maybe just give us a quick overview of BDK, how core fits in and maybe the evolution of those two different pieces of software.

39
00:36:33,581 --> 00:41:18,320
Speaker 1: Yeah, so well, maybe I'll start from the last question. So what is BDK? BDK is a Rust-like that can be used to build generic Bitcoin wallets. And when I say generic, I mean generic in terms of policy. So we were talking about miniscript before. BDK uses miniscript so you can build a wallet. I don't know. There is a simple single-sig. You can build a multi-sig. You can build complex wallets where you have time locks and complex conditions. And this is what we mean by generic. Like in theory with BDK, you can build, let's say, any kind of wallet you want. Obviously, there are limitations, but that is kind of the goal. So we want to basically build the library that is very flexible, that can adapt to different use cases. Like you're building a desktop wallet, mobile wallet or web wallet. We want to be able to do a bit of everything. And BDK has been, it's a project we started in 2020, I think. So it's been kind of being developed for two or three years now. And at some point we realized that if you, basically BDK would work well for most use cases, like for most users, especially users that don't need any kind of advanced features, like users that maybe don't even have a deep knowledge of Bitcoin. They just want to build something kind of simple. For those users, BDK would work well. But as soon as somebody wanted to do something a bit more complicated, some kind of more complex protocols, some kind of basically something that would need a more low-level access, BDK would not work really well for them. Because BDK is this kind of simple API that you use. And if the API is good for you, that's fine. But if you need something more low-level, you will not really be able to do that. And the other thing we realized was that BDK was this kind of monolithic thing that would do a little bit of everything. So when you think of a wallet, you have many different components that work together. So, for example, you have code to monitor the chain so you can see when you receive funds, you have code to do coin selection, for example. You have logic to create a transaction. When you construct a transaction, obviously you do coin selection. But on top of that, there's also some logic for setting the correct fields, the correct analog time and sequence, stuff like that. And BDK was just one library basically doing all of this. And we also realized that maybe some people would be interested in using some of these components, maybe not necessarily the old BDK library. Maybe somebody is just interested in taking the code to monitor the chain for some project they're building. So for what these reasons, since we wanted to offer a more low-level access and since we wanted users to be able to use individual pieces of BDK, we started this BDK core sub-project. It was kind of a parallel project that went on for a little while. So BDK, the library, was still being developed. But in the meantime, some other people, mainly Lloyd, they were working on this BDK core concept. And the idea was to basically have different components that work together, but that can also be used independently. And so at this point, I think BDK core has been going on for many months, maybe even a year. I don't remember exactly when it started. At this point, we are confident BDK core, or let's say using the BDK core components together, would make a much better BDK because it would give users a lot more flexibility. They would be able to get more low-level access if they want to, while they could also keep using kind of the same old API if all these components work together. So they don't necessarily have to use the low-level thing. They can also use all of them together and just get an easy API. And so this PR, this 793, was basically merging these BDK core components within BDK. So now the BDK repo is composed of a few different crates. So there are the crates is just Rust language for like packages. And so now there are in the BDK repo, there are these BDK core components that you can use independently if you want. And then there's the BDK crate, which has been refactored to essentially use those components inside. So if you are a BDK user and you were using the full library, the API doesn't really change all that much. There are improvements there as well that are kind of a consequence of the BDK core restructuring. So the normal BDK API is improving a little bit, is getting more flexible, but it's mostly staying unchanged. So for BDK users, that doesn't really make any difference. But for maybe users that looked into BDK in the past and I don't know, figured BDK would not be for them because it was not flexible enough, not offer something. With this refactoring, it would maybe be useful for them. Like it could become useful for them. They could reevaluate because now they would get this lower level access kind of thing. Yeah, I think this is pretty much all. I don't know if I've covered what you had in mind.

40
00:41:18,801 --> 00:41:37,299
Speaker 0: No, that was great. Maybe a quick note from you about whether it's new users or existing users of BDK. Maybe the timing in what you're looking for in terms of like testing or feedback on this. What should folks do if they're interested or they're using BDK currently?

41
00:41:37,721 --> 00:43:06,760
Speaker 1: Yeah, that's a really good question. So I would say I'm not super up to date about the time, let's say when this is going to be ready and released because the original plan was to be ready at the beginning of this year. So this thing has been delayed a little bit. And as I said before, now I'm kind of lowering my effort there. So I don't know when this will be like 100% ready. But the fact that it's been merged into master, it means that it's getting there. So now mainly what we need is testing and feedback from users. So what I would say is if you're a user of BDK, you could try switching to basically to using master instead of using release version and see what happens. You probably are going to have to make some changes to the way you interact with BDK. It should be mostly minor changes, but I don't know if something goes wrong. If for some reason you need big changes, let us know. So for current users, I would say just try to update and see what happens and provide feedback. For people who are considering using BDK, maybe just don't look at the current release version because currently the latest release is still based on the old architecture. So maybe if you look at the latest release, you think, oh, BDK is not for me. If you want to spend some time, look at this PR and look at the documentation around BDK core because once this will be released, I think it would be a pretty major change in terms of how powerful the library would be, what kind of things it will offer. Yeah.

42
00:43:08,344 --> 00:43:14,558
Speaker 0: Excellent. Murch, do you have any questions or comments on this BDK PR and the bigger project?

43
00:43:15,840 --> 00:43:41,879
Speaker 2: No, that sounds great. Yeah. So the way I understood it is you basically have refactored the inner parts or the inner workings of BDK into a library that you use yourself to still provide the old API of BDK. But now the library components themselves are standalone usable by other people that have needs that are more low level. Is that a good summary?

44
00:43:42,620 --> 00:44:24,657
Speaker 1: Yeah. Yeah. That's pretty much it. So now we have like most of the refactoring was actually around the code that monitors the chain and the code that persists like your transactions, your UTXOs on disk. So this is where we focus the most. So there are like components that you can use. if you have a project that just needs to monitor the chain, you can just use those components individually without having the old BDK wallet thing. Then I think one other component was the current selection because before it was kind of embedded within BDK. Now it's a separate module. I think I'm not sure about that, but that was one of the ideas with BDK Core. So if it's not there yet, it should come soon. And then yeah, that's pretty much it. And then BDK has been refactored to use those components internally.

45
00:44:25,500 --> 00:44:33,596
Speaker 2: Very good. Cool. That's also impressive that you guys managed to do that so quickly. And we've been working on this for a Bitcoin Core for five years or so.

46
00:44:36,321 --> 00:44:46,299
Speaker 1: Yeah. I mean, I think being a smaller project obviously is much easier to iterate and move faster on Bitcoin Core. It's everything takes longer.

47
00:44:46,500 --> 00:45:06,998
Speaker 0: If anybody in the spaces has a question, feel free to raise your hand or request speaker access. We did have one comment that I wanted to get your thoughts on, Merch, which is someone saying CPFP is a crime against Bitcoin. Merch, what do you think about CPFP being a crime against Bitcoin or not?

48
00:45:07,680 --> 00:46:10,679
Speaker 2: I feel like that has a little, could use more context. I think that generally there's different approaches on how you can change your mind about transactions or reprioritize transactions. So of course, replace by fee where you just make a conflicting transaction that has a higher fee rate is cleaner in that it uses less block space. But that obviously can only be done by the sender. CPFP is also available to recipients. Either of them have a privacy impact in. if somebody watches for what transactions conflict with each other, they can probably guess if different inputs were used that the other inputs are also controlled by the same sender or senders with CPFP. I see they will guess that either the recipient or the sender attached their transaction so they might be able to glean more information on who the output went to in that regard. I don't know what else would be criminal about CPFP. So more context would help.

49
00:46:11,926 --> 00:47:12,879
Speaker 0: Hey, Rendell. Good morning. I actually came up, I had a question about the new BDK 1.0 architecture. Really excited to see the refactoring happening. I've written a lot of small processes that just use parts of BDK, but you kind of had to create the whole wallet even if you didn't use all of it. So I'm excited to be able to pick and choose components out of BDK to use. Do you think that the big refactoring is also going to have an impact on the APIs that are exposed through the FFI layer to languages like Swift or Kotlin? Or do you think it's primarily going to be like a Rust component refactor? I'm thinking about different projects that I work on that use BDK and trying to get some sense of like how much code we're going to have to go rewrite. If it's mostly just on the Rust side, that's kind of different than if those changes flow through all the layers of FFI to get to something like Swift or Kotlin.

50
00:47:13,580 --> 00:48:03,059
Speaker 1: I think some changes will get to FFI as well, but it should be mostly smaller changes because the FFI tries to mirror as much as possible the Rust API. And one of the goals here is to not change the Rust API too much. But if we do change, and one thing where it needs to change for sure is around the syncing because again, most of BDK core was focused around monitoring the chain. So syncing is the term we use in BDK for synchronizing your internal state with the chain. So I don't know if there are any transactions for you, you store them in your kind of cache. So the code around syncing will change a little bit, but it's really you can see. you can check out the examples in the PR. I think it's like four lines of code that needs to change in Rust. And it's probably going to be like more or less the same in FFI because again, we kind of mirror the API as much as possible.

51
00:48:03,845 --> 00:48:11,517
Speaker 0: Great, thanks. Doesn't look like there's any other questions. Murch, anything else that you would like the listeners to be aware of before we sign off?

52
00:48:12,400 --> 00:48:29,259
Speaker 2: Oh, I found another way how CPFP could be a crime. So I know of some Bitcoin developers that would much prefer if we weren't able to spend unconfirmed outputs at all. So in that regard, it might also be a crime. All right. No, I have nothing else. Thank you, Guy.

53
00:48:29,480 --> 00:48:36,818
Speaker 0: I'm sure you could do CPFP for PSBT offers and ordinals and just piss off more people.

54
00:48:37,400 --> 00:48:41,295
Speaker 2: If we're just looking to be angry about things, there's plenty to go around with.

55
00:48:43,080 --> 00:48:58,999
Speaker 0: Well, thank you, Alekos, for joining us and talking about BDK. Thanks to my co-host Murch. And thank you all for joining and participating in CoinOptech newsletter number 243. And we'll talk to you guys next week. Cheers.

56
00:48:59,522 --> 00:48:59,885
Speaker 2: Cheers.

57
00:49:00,451 --> 00:49:00,996
Speaker 1: Bye. Thank you.

